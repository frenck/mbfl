\input texinfo.tex
@c $Id: MBFL.texi,v 1.1.1.10 2004/02/05 08:09:09 marco Exp $
@c %**start of header
@setfilename MBFL.info
@settitle Marco's BASH Functions Library
@c %**end of header

@include version.texi
@syncodeindex fn cp

@c ------------------------------------------------------------
@titlepage
@title Marco's BASH Functions Library
@subtitle @version.texi
@author Marco Maggi
@page
@vskip 0pt plus 1filll
@noindent
Copyright @copyright{}  2003, 2004  by Marco Maggi.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back--Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end titlepage


@c ------------------------------------------------------------
@ifinfo
@dircategory Development
@direntry
* MBFL: (MBFL).                 Marco's BASH Functions Library. 
@end direntry
@end ifinfo


@c ------------------------------------------------------------
@ifnottex
@node Top
@top Marco's BASH Functions Library

@noindent
This file documents version @version{} or @acronym{MBFL}, a collection
of @acronym{GNU} @command{bash} shell functions.

Copyright @copyright{}  2003, 2004  by Marco Maggi.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back--Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
     
@menu
* Overview::                    Overview of this document. 
* Encoding::                    Encoding and decoding strings.
* File::                        Manipulating files and pathnames.
* Getopt::                      Parsing command line options.
* Message::                     Printing messages to the console.
* Program::                     Using external programs.
* Signal::                      Catching signals.
* String::                      Manipulating strings.
* Dialog::                      Interacting with the user.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* References::                  Bibliography and references.

Indexes

* Concept Index::               An entry for each concept. 
@end menu
@end ifnottex


@c ------------------------------------------------------------
@node Overview
@unnumbered Overview of this document


@noindent
This package is an attempt to make @acronym{GNU} @command{bash} a viable
solution for medium sized scripts. A problem with bash is that it
doesn't provide encapsulation of any sort, beside the feature of
providing functions.

A set of modules implementing common operations and a script template
are provided by the package and the author has used them with success in
implementing non--small scripts.

The philosophy of @acronym{MBFL} is to do the work as much as possible
without external commands. For example: string manipulation is done
using the special variable substitution provided by @command{bash}, and
no use is done of utilities like @command{sed}, @command{grep} and
@command{ed}.

The best way to use the library is to include the single file
@file{libMBFL.sh} directly in the script. This is easy if we preprocess
our scripts with @acronym{GNU} @command{m4}; as we can see in the
template file (subdirectory @file{src/examples} of the source tree):

@example
m4_changequote([[, ]])
m4_include(libMBFL.sh)
@end example

@noindent
is all we need to do. We can preprocess the script with:

@example
$ m4 --prefix-builtins --include=/path/to/library \
         script.sh.m4 >script.sh
@end example

@noindent
easy to do in a @file{Makefile}; we can take the @acronym{MBFL}'s
@file{Makefile} as example of this method.

At present: a module in the library is not working at all: the signal
one. Ignore completely the functions whose name begin with
@code{mbfl_signal}.

@c ------------------------------------------------------------
@node Encoding
@unnumbered Encoding and decoding strings


@noindent
The purpose of this module is to let an external process invoke a
@command{bash} script with @emph{damn}command line arguments: strings
including blanks or strange characters that may trigger quoting rules.

This problem can arise when using scripting languages with some sort of
@code{eval} command.

The solution is to encode the argument string in hexadecimal or octal
format strings, so that all the damn characters are converted to
``good'' ones. The the @command{bash} script can convert them back.


@deffn Function mbfl_decode_hex @var{string}
Decodes a hex string and outputs it on stdout.
@end deffn


@deffn Function mbfl_decode_oct @var{string}
Decodes a oct string and outputs it on stdout.
@end deffn


Example:

@example
mbfl_decode_hex 414243
-> ABC
@end example

@c ------------------------------------------------------------
@node File
@unnumbered Manipulating files and pathnames


@deffn Function mbfl_file_extension @var{pathname}
Extracts the extension from a file name.  Searches the last dot
character in the argument string and echoes to stdout the range of
characters from the dot to the end, not including the dot.  If a slash
character is found first, echoes to stdout the empty string.
@end deffn


@deffn Function mbfl_file_dirname @var{pathname}
Extracts the directory part from a fully qualified file name.  Searches
the last slash character in the input string and echoes to stdout the
range of characters from the first to the slash, not including the
slash.

If no slash is found: echoes a single dot (the current directory).

If the input string begins with @code{/} or @code{//} with no slash
characters after the first ones, the string echoed to stdout is a single
slash.
@end deffn


@deffn Function mbfl_file_normalise @var{pathname}
Normalises a file name.  If the input string is a relative name, the
current process working directory is prepended to it.  Echoes to stdout
the normalised file name.
@end deffn


@deffn Function mbfl_file_rootname @var{pathname}
Extracts the root portion of a file name.  Searches the last dot
character in the argument string and echoes to stdout the range of
characters from the beginning to the dot, not including the dot.

If a slash character is found first, or no dot is found, or the dot is
the first character, echoes to stdout the empty string.
@end deffn


@deffn Function mbfl_file_split @var{pathname}
Separates a file name into its components.
Replaces all the slash characters in the input string
with a newline and echoes the substrings.

The correct way to use the fields is:

@example
mbfl_file_split "$file" | while read field
do
   ... $field ...
done
@end example
@end deffn


@deffn Function mbfl_file_tail @var{pathnbame}
Extracts the file portion from a fully qualified file name.  Searches
the last slash character in the input string and echoes to stdout the
range of characters from the slash to the end, not including the slash.
If no slash is found: echoes the whole string.
@end deffn


@deffn Function mbfl_file_find_tmpdir @var{PATHNAME}
Finds a value for a temporary directory. If @var{PATHNAME} is not null
and is a directory and is writable it is accepted; else the value
@file{/tmp/$USER}, where @env{USER} is the environment variable, is
tried; finally the value @file{/tmp} is tried. When a value is accepted
it's echoed to stdout. Returns true if a value is found, false
otherwise.
@end deffn

@c ------------------------------------------------------------
@node Getopt
@unnumbered Parsing command line options


@noindent
The getopt module defines a set of procedures to be used to process
command line arguments with the following format:

@table @code
@item -a
brief option @code{a} with no value;

@item -a123
brief option @code{a} with value @code{123};

@item --bianco
long option @code{bianco} with no value;

@item --color=bianco
long option @code{color} with value @code{bianco}.
@end table

The module contains, at the root level, a block of code like the
following:

@example
ARGC=0
ARGC1=0
declare -a ARGV ARGV1

while test $# -gt 0
do
    ARGV1[$ARGC1]=$1
    ARGC1=$(($ARGC1 + 1))
    shift
done
@end example

@noindent
this block is executed when the script is evaluated. Its purpose is to
store command line arguments in the global array @code{ARGV1} and the
number of command line arguments in the global variable @code{ARGC1}.

The global array @code{ARGV} and the global variable @code{ARGC} are
predefined and should be used by the @code{mbfl_getopts} functions to
store non--option command line arguments.

Example:

@example
$ script --gulp wo --gasp=123 wo
@end example

@noindent
if such a script makes use of this module, the strings @code{wo} and
@code{wa} will go into @code{ARGV} and @code{ARGC} will be set to 2. The
option arguments are processed and some action is performed to register
them.

To use this module we have invoke:

@example
mbfl_getopts_parse
@end example

@noindent
and declare two functions: @code{mbfl_getopts_option()} and
@code{mbfl_getopts_option_with()}. They are invoked by
@code{mbfl_getopts_parse} to register command line options presence and
to store somewhere the option's values.


@deffn {User Function} mbfl_getopts_option @var{option}
Invoked to register the presence, on the command line, of an option with
no argument. @var{option} is the option string with no leading dashes.
@end deffn


@deffn {User Function} mbfl_getopts_option_with @var{option} @var{value}
Invoked to register the presence, on the command line, of an option with
argument. @var{option} is the option string with no leading dashes,
@var{value} is the value assigned to the option.
@end deffn


Now the interface functions.


@deffn Function mbfl_getopts_parse
Parses a set of command line options. The options are handed to user
defined functions.

The global array @code{ARGV1} and the global variable @code{ARGC1} are
supposed to hold the command line arguments and the number of command
line arguments.

When an option without argument is found: @code{mbfl_getopts_option()}
is called with the option name, without dashes, as first argument; when
an option with argument is found: @code{mbfl_getopts_option_with()} is
called with the option name, without dashes, as first argument and the
option value as second argument.

Non--option arguments are left in the global array @code{ARGV}, the
global variable @code{ARGC} holds the number of elements in @code{ARGV}.
@end deffn


@deffn Function mbfl_getopts_islong @var{string} @var{varname}
Verifies if a string is a long option without argument.  @var{string} is
the string to validate, @var{varname} is the optional name of a variable
that's set to the option name, without the leading dashes

Returns with code zero if the string is a long option without argument,
else returns with code one.

An option must be of the form @code{--option}, only characters in the
ranges @code{A-Z}, @code{a-z}, @code{0-9} and the characters @code{-}
and @code{_} are allowed in the option name.
@end deffn


@deffn Function mbfl_getopts_islong_with @var{string} @var{optname} @var{valname}
Verifies if a string is a long option with argument. Arguments:

@table @var
@item string
the string to validate;

@item optname
optional name of a variable that's set to the option name, without the
leading dashes;

@item valname
optional name of a variable that's set to the option value.
@end table

Returns with code zero if the string is a long option with argument,
else returns with code one.

An option must be of the form @code{--option=value}, only characters in
the ranges @code{A-Z}, @code{a-z}, @code{0-9} and the characters
@code{-} and @code{_} are allowed in the option name.

If the argument is not an option with value, the variable names are
ignored.
@end deffn


@deffn Function mbfl_getopts_isbrief @var{string} @var{varname}
Verifies if a string is a brief option without argument. Arguments:
@var{string} is the string to validate, @var{varname} optional name of a
variable that's set to the option name, without the leading dash.

Returns with code zero if the argument is a brief option without
argument, else returns with code one.

A brief option must be of the form @code{-a}, only characters in the
ranges @code{A-Z}, @code{a-z}, @code{0-9} are allowed as option letters.
@end deffn


@deffn Function mbfl_getopts_isbrief_with @var{string} @var{optname} @var{valname}
Verifies if a string is a brief option without argument. Arguments:

@table @var
@item string
the string to validate;

@item optname
optional name of a variable that's set to the option name, without the
leading dashes;

@item valname
optional name of a variable that's set to the option value.
@end table

Returns with code zero if the argument is a brief option without
argument, else returns with code one.

A brief option must be of the form @code{-aV} (@code{a} is the option,
@code{V} is the value), only characters in the ranges @code{A-Z},
@code{a-z}, @code{0-9} are allowed as option letters.
@end deffn


@deffn Function mbfl_getopts_decode_hex
Decodes non--option arguments. Requires @code{mbfl_decode_hex()}.  In
hex--coding, each byte in the argument is replaced by its representation
in hex number.

Decodes hex--coded arguments in the @code{ARGV} array. This function can
be invoked if the command line arguments have been encoded.
@end deffn


@deffn Function mbfl_wrong_num_args @var{required} @var{present}
Validates the number of arguments.  @var{required} is the required
number of arguments, @var{present} is the given number of arguments on
the command line.

If the number of arguments is different from the required one: prints an
error message and returns with code one; else returns with code zero.

Requires the message module (@ref{Message} for details).
@end deffn


@deffn mbfl_argv_from_stdin
If the @code{ARGC} global variable is set to zero: fills the global
variable @code{ARGV} with lines from stdin. If the global variable
@code{mbfl_option_NULL} is set to @code{yes}: lines are read using the
null character as terminator, else they are read using the standard
newline as terminator.
@end deffn


@deffn mbfl_argv_all_files
Checks that all the arguments in @code{ARGV} are file names of existent
file.  Returns with code zero if no errors, else prints an error message
and returns with code 1.
@end deffn


@c ------------------------------------------------------------
@node Message
@unnumbered Printing messages to the console


@noindent
This module allows one to print messages on an output channel. Various
forms of message are supported.

All the function names are prefixed with @code{mbfl_message_}. All the
messages will have the forms:

@example
<progname>: <message>
<progname> [error|warning]: <message>
@end example

The following global variables are declared:

@table @code
@item mbfl_message_PROGNAME
must be initialised with the name of the script that'll be displayed at
the beginning of each message;

@item mbfl_message_VERBOSE
@code{yes} if verbose messages should be displayed, else @code{no};

@item mbfl_message_DEBUGGING
@code{yes} if debugging messages should be displayed, else @code{no};

@item mbfl_message_STDERR
the channel used to output messages.
@end table


@deffn Function mbfl_message_set_program @var{PROGNAME}
Sets the script official name to put at the beginning of messages.
@end deffn


@deffn Function mbfl_message_set_verbosity @var{value}
Stores a value in @code{mbfl_message_VERBOSE}.
@end deffn


@deffn Function mbfl_message_set_debugging @var{string}
If @var{string} is @code{yes} debug message are enabled, if it's
@code{no} are disabled.
@end deffn


@deffn Function mbfl_message_set_stderr @var{channel}
Selects the channel to be used to output messages.
@end deffn


@deffn Function mbfl_message_string @var{string}
Outputs a message to the selected channel.  Echoes a string composed of:
the content of the @code{mbfl_message_PROGNAME} global variable; a
colon; a space; the provided message.

A newline character is NOT appended to the message. Escape characters
are allowed in the message.
@end deffn


@deffn Function mbfl_message_verbose @var{string}
Outputs a message to the selected channel, but only if the global
variable @code{mbfl_message_VERBOSE} is set to @code{yes}.

Echoes a string composed of: the content of the
@code{mbfl_message_PROGNAME} global variable; a colon; a space; the
provided message.

A newline character is NOT appended to the message. Escape characters
are allowed in the message.
@end deffn


@deffn Function mbfl_message_verbose_end @var{string}
Outputs a message to the selected channel, but only if the global
variable @code{mbfl_message_VERBOSE} is set to @code{yes}.

Echoes the string. A newline character is NOT appended to the
message. Escape characters are allowed in the message.
@end deffn


@deffn Function mbfl_message_debug @var{string}
Outputs a message to the selected channel, but only if the global
variable @code{mbfl_message_DEBUGGING} is set to @code{yes}.

Echoes a string composed of: the content of the
@code{mbfl_message_PROGNAME} global variable; a colon; a space; the
provided message.

A newline character is NOT appended to the message. Escape characters
are allowed in the message.
@end deffn


@deffn Function mbfl_message_warning @var{string}
Outputs a warning message to the selected channel.  Echoes a string
composed of: the content of the @code{mbfl_message_PROGNAME} global
variable; a space; the string @code{warning}; a colon; a space; the
provided message.

A newline character IS appended to the message. Escape characters are
allowed in the message.
@end deffn


@deffn Function mbfl_message_error @var{string}
Outputs a error message to the selected channel.  Echoes a string
composed of: the content of the @code{mbfl_message_PROGNAME} global
variable; a space; the string @code{error}; a colon; a space; the
provided message.

A newline character IS appended to the message. Escape characters are
allowed in the message.
@end deffn


@c ------------------------------------------------------------
@node Program
@unnumbered Using external programs


@noindent
This module declares a set of global variables all prefixed with
@code{program_}. We have to look at the module's code to see which one
are declared.


@deffn Function mbfl_program_check @var{program} ?@var{program} ...?
Checks the availability of programs. This function assumes that the
program pathnames do not contain blank characters. All the pathnames on
the command line are checked: if one is not executable an error message
is printed.

Returns true if a program can't be found, false otherwise.

Requires the message module (@ref{Message} for details).
@end deffn


@deffn Function mbfl_program_exec @var{arg} ...
Evaluates a command line. If the variable @code{mbfl_program_TEST} is
set to @code{yes}: instead of evaluation, the command line is sent to
stderr.
@end deffn

@c ------------------------------------------------------------
@node Signal
@unnumbered Catching signals


@noindent
This module is under development.

@c ------------------------------------------------------------
@node String
@unnumbered Manipulating strings


@deffn Function mbfl_string_chars @var{string}
Splits a string into characters.  Echoes to stdout the characters one
per line.

The correct way to use the fields is:

@example
mbfl_string_chars $string $sep | while read ch
do
   ... $ch ...
done
@end example
@end deffn


@deffn Function mbfl_string_first @var{string} @var{char} @var{begin}
Searches characters in a string. Arguments:

@table @var
@item string
the target string;

@item char
the character to look for;

@item begin
optional, the index of the character in the target string from which the
search begins; defaults to zero.
@end table

Echoes to stdout an integer representing the index of the first
occurrence of @var{char} in @var{string}. If the character is not found:
nothing is sent to stdout.
@end deffn


@deffn Function mbfl_string_index @var{string} @var{index}
Selects a character from a string.  Echoes to stdout the selected
character. If the index is out of range: the empty string is echoed to
stdout.
@end deffn


@deffn Function mbfl_string_is @var{class} @var{string}
Tests a string agains a character class. Supported classes are:

@table @code
@item alpha
characters in the range @code{A-Z} and @code{a-Z};

@item digit
characters in the range @code{0-9};

@item alnum
character of the classes @code{alpha} and @code{digit};

@item noblank
all the characters excluding @code{ \n\t\r\f};

@item name
a string of characters numbers and underscores, with the first character
not being a number.
@end table

@var{class} is the class name, @var{string} is the source string, a null
string is of no class.

Returns with code 0 if the string is of the selected class, else returns
with code 1.
@end deffn


@deffn Function mbfl_string_last @var{string} @var{char} @var{begin}
Searches characters in a string starting from the end. Arguments:

@table @var
@item string
the target string;

@item char
the character to look for;

@item begin
optional, the index of the character in the target string from which the
search begins; defaults to zero.
@end table

Echoes to stdout an integer representing the index of the last
occurrence of @code{sring} in @code{char}. If the character is not
found: nothing is sent to stdout.
@end deffn


@deffn Function mbfl_string_range @var{string} @var{begin} @var{end}
Extracts a range of characters from a string. Arguments:

@table @var
@item string
the source string;

@item begin
the index of the first character in the range;

@item end
optional, the index of the character next to the last in the range, this
character is not extracted; defaults to the last character in the
string; if equal to @code{end}: the end of the range is the end of the
string.
@end table

Echoes to stdout the selected range of characters.
@end deffn


@deffn Function mbfl_string_split @var{string} @var{split}
Splits a string into fields. This is done replacing each character from
a selected set with a newline. If the source string contains newlines
the splitting operation can lead to unexpected results.

@var{string} is the source string, @var{split} is the string made up of
characters to be used as field separators.

Echoes to stdout the fields one per line.

The correct way to use the fields is:

@example
mbfl_string_split $string $sep | while read field
do
   ... $field ...
done
@end example
@end deffn


@c ------------------------------------------------------------
@node Dialog
@unnumbered Interacting with the user


@deffn Function mbfl_dialog_yes_or_no @var{string}
Prints the question @var{string} on the standard output and waits for
the user to type @code{yes} or @code{no} in the standard input. Returns
true if the user has typed @code{yes}, false if the user has typed
@code{no}.
@end deffn


@c ------------------------------------------------------------

@include fdl.texiinc
@include lgpl.texiinc

@c ------------------------------------------------------------
@node References
@appendix Bibliography and references


@table @emph
@item bash Manual Page
By Brian Fox and Chet Ramey. The authoritative source for @command{bash}
behaviour.

@end table
@c ------------------------------------------------------------
@node Concept Index
@appendix An entry for each concept
     
@printindex cp
     
@contents
@bye

@c end of file
@c Local Variables:
@c mode: texinfo
@c page-separator: "^@c -+$"
@c End:
